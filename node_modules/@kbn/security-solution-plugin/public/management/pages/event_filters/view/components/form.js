"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventFiltersForm = void 0;
var _react = _interopRequireWildcard(require("react"));
var _lodash = require("lodash");
var _eui = require("@elastic/eui");
var _i18nReact = require("@kbn/i18n-react");
var _securitysolutionListUtils = require("@kbn/securitysolution-list-utils");
var _securitysolutionUtils = require("@kbn/securitysolution-utils");
var _public = require("@kbn/lists-plugin/public");
var _constants = require("../../../../../../common/endpoint/constants");
var _use_suggestions = require("../../../../hooks/use_suggestions");
var _use_test_id_generator = require("../../../../hooks/use_test_id_generator");
var _source = require("../../../../../common/containers/source");
var _loader = require("../../../../../common/components/loader");
var _use_license = require("../../../../../common/hooks/use_license");
var _kibana = require("../../../../../common/lib/kibana");
var _artifacts = require("../../../../../../common/endpoint/service/artifacts");
var _event_filters_list = require("../event_filters_list");
var _translations = require("../../../../common/translations");
var _constants2 = require("../../constants");
var _effected_policy_select = require("../../../../components/effected_policy_select");
var _utils = require("../../../../components/effected_policy_select/utils");
var _item_comments = require("../../../../../detection_engine/rule_exceptions/components/item_comments");
var _api_client = require("../../service/api_client");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const OPERATING_SYSTEMS = [_securitysolutionUtils.OperatingSystem.MAC, _securitysolutionUtils.OperatingSystem.WINDOWS, _securitysolutionUtils.OperatingSystem.LINUX];

// OS options
const osOptions = OPERATING_SYSTEMS.map(os => ({
  value: os,
  inputDisplay: _translations.OS_TITLES[os]
}));
const getAddedFieldsCounts = formFields => formFields.reduce((allFields, field) => {
  if (field in allFields) {
    allFields[field]++;
  } else {
    allFields[field] = 1;
  }
  return allFields;
}, {});
const computeHasDuplicateFields = formFieldsList => Object.values(formFieldsList).some(e => e > 1);
const defaultConditionEntry = () => [{
  field: '',
  operator: 'included',
  type: 'match',
  value: ''
}];
const cleanupEntries = item => {
  return item.entries.map(e => {
    delete e.id;
    return e;
  });
};
const EventFiltersForm = /*#__PURE__*/(0, _react.memo)(({
  allowSelectOs = true,
  item: exception,
  policies,
  policiesIsLoading,
  onChange,
  mode
}) => {
  const getTestId = (0, _use_test_id_generator.useTestIdGenerator)('eventFilters-form');
  const {
    http
  } = (0, _kibana.useKibana)().services;
  const getSuggestionsFn = (0, _react.useCallback)(({
    field,
    query
  }) => {
    const eventFiltersAPIClient = new _api_client.EventFiltersApiClient(http);
    return eventFiltersAPIClient.getSuggestions({
      field: field.name,
      query
    });
  }, [http]);
  const autocompleteSuggestions = (0, _use_suggestions.useSuggestions)(getSuggestionsFn);
  const [hasFormChanged, setHasFormChanged] = (0, _react.useState)(false);
  const [hasNameError, toggleHasNameError] = (0, _react.useState)(!exception.name);
  const [newComment, setNewComment] = (0, _react.useState)('');
  const [hasCommentError, setHasCommentError] = (0, _react.useState)(false);
  const [hasBeenInputNameVisited, setHasBeenInputNameVisited] = (0, _react.useState)(false);
  const [selectedPolicies, setSelectedPolicies] = (0, _react.useState)([]);
  const isPlatinumPlus = (0, _use_license.useLicense)().isPlatinumPlus();
  const isGlobal = (0, _react.useMemo)(() => (0, _artifacts.isArtifactGlobal)(exception), [exception]);
  const [wasByPolicy, setWasByPolicy] = (0, _react.useState)(!(0, _utils.isGlobalPolicyEffected)(exception === null || exception === void 0 ? void 0 : exception.tags));
  const [hasDuplicateFields, setHasDuplicateFields] = (0, _react.useState)(false);
  // This value has to be memoized to avoid infinite useEffect loop on useFetchIndex
  const indexNames = (0, _react.useMemo)(() => [_constants.eventsIndexPattern], []);
  const [isIndexPatternLoading, {
    indexPatterns
  }] = (0, _source.useFetchIndex)(indexNames, undefined, _constants.ENDPOINT_FIELDS_SEARCH_STRATEGY);
  const [areConditionsValid, setAreConditionsValid] = (0, _react.useState)(!!exception.entries.length || false);
  // compute this for initial render only
  const existingComments = (0, _react.useMemo)(() => exception === null || exception === void 0 ? void 0 : exception.comments,
  // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
  const showAssignmentSection = (0, _react.useMemo)(() => {
    return isPlatinumPlus || mode === 'edit' && (!isGlobal || wasByPolicy && isGlobal && hasFormChanged);
  }, [mode, isGlobal, hasFormChanged, isPlatinumPlus, wasByPolicy]);
  const isFormValid = (0, _react.useMemo)(() => {
    // verify that it has legit entries
    // and not just default entry without values
    return !hasNameError && !hasCommentError && !!exception.entries.length && exception.entries.some(e => e.value !== '' || e.value.length);
  }, [hasCommentError, hasNameError, exception.entries]);
  const processChanged = (0, _react.useCallback)(updatedItem => {
    const item = updatedItem ? {
      ...exception,
      ...updatedItem
    } : exception;
    cleanupEntries(item);
    onChange({
      item,
      isValid: isFormValid && areConditionsValid
    });
  }, [areConditionsValid, exception, isFormValid, onChange]);

  // set initial state of `wasByPolicy` that checks
  // if the initial state of the exception was by policy or not
  (0, _react.useEffect)(() => {
    if (!hasFormChanged && exception.tags) {
      setWasByPolicy(!(0, _utils.isGlobalPolicyEffected)(exception.tags));
    }
  }, [exception.tags, hasFormChanged]);

  // select policies if editing
  (0, _react.useEffect)(() => {
    if (hasFormChanged) return;
    const policyIds = exception.tags ? (0, _artifacts.getPolicyIdsFromArtifact)({
      tags: exception.tags
    }) : [];
    if (!policyIds.length) return;
    const policiesData = policies.filter(policy => policyIds.includes(policy.id));
    setSelectedPolicies(policiesData);
  }, [hasFormChanged, exception, policies]);
  const eventFilterItem = (0, _react.useMemo)(() => {
    const ef = exception;
    ef.entries = exception.entries.length ? exception.entries : defaultConditionEntry();

    // TODO: `id` gets added to the exception.entries item
    // Is there a simpler way to this?
    cleanupEntries(ef);
    setAreConditionsValid(!!exception.entries.length);
    return ef;
  }, [exception]);

  // name and handler
  const handleOnChangeName = (0, _react.useCallback)(event => {
    if (!exception) return;
    const name = event.target.value.trim();
    toggleHasNameError(!name);
    processChanged({
      name
    });
    if (!hasFormChanged) setHasFormChanged(true);
  }, [exception, hasFormChanged, processChanged]);
  const nameInputMemo = (0, _react.useMemo)(() => {
    var _exception$name;
    return /*#__PURE__*/_react.default.createElement(_eui.EuiFormRow, {
      label: _event_filters_list.NAME_LABEL,
      fullWidth: true,
      isInvalid: hasNameError && hasBeenInputNameVisited,
      error: _event_filters_list.NAME_ERROR
    }, /*#__PURE__*/_react.default.createElement(_eui.EuiFieldText, {
      "aria-label": _event_filters_list.NAME_LABEL,
      id: "eventFiltersFormInputName",
      defaultValue: (_exception$name = exception === null || exception === void 0 ? void 0 : exception.name) !== null && _exception$name !== void 0 ? _exception$name : '',
      "data-test-subj": getTestId('name-input'),
      fullWidth: true,
      maxLength: 256,
      required: hasBeenInputNameVisited,
      onChange: handleOnChangeName,
      onBlur: () => !hasBeenInputNameVisited && setHasBeenInputNameVisited(true)
    }));
  }, [getTestId, hasNameError, handleOnChangeName, hasBeenInputNameVisited, exception === null || exception === void 0 ? void 0 : exception.name]);

  // description and handler
  const handleOnDescriptionChange = (0, _react.useCallback)(event => {
    if (!exception) return;
    if (!hasFormChanged) setHasFormChanged(true);
    processChanged({
      description: event.target.value.toString().trim()
    });
  }, [exception, hasFormChanged, processChanged]);
  const descriptionInputMemo = (0, _react.useMemo)(() => {
    var _exception$descriptio;
    return /*#__PURE__*/_react.default.createElement(_eui.EuiFormRow, {
      label: _event_filters_list.DESCRIPTION_LABEL,
      fullWidth: true
    }, /*#__PURE__*/_react.default.createElement(_eui.EuiTextArea, {
      id: "eventFiltersFormInputDescription",
      defaultValue: (_exception$descriptio = exception === null || exception === void 0 ? void 0 : exception.description) !== null && _exception$descriptio !== void 0 ? _exception$descriptio : '',
      onChange: handleOnDescriptionChange,
      fullWidth: true,
      "data-test-subj": getTestId('description-input'),
      "aria-label": _event_filters_list.DESCRIPTION_LABEL,
      maxLength: 256
    }));
  }, [exception === null || exception === void 0 ? void 0 : exception.description, getTestId, handleOnDescriptionChange]);

  // selected OS and handler
  const selectedOs = (0, _react.useMemo)(() => {
    var _exception$os_types;
    if (!(exception !== null && exception !== void 0 && (_exception$os_types = exception.os_types) !== null && _exception$os_types !== void 0 && _exception$os_types.length)) {
      return _securitysolutionUtils.OperatingSystem.WINDOWS;
    }
    return exception.os_types[0];
  }, [exception === null || exception === void 0 ? void 0 : exception.os_types]);
  const handleOnOsChange = (0, _react.useCallback)(os => {
    if (!exception) return;
    processChanged({
      os_types: [os],
      entries: exception.entries
    });
    if (!hasFormChanged) setHasFormChanged(true);
  }, [exception, hasFormChanged, processChanged]);
  const osInputMemo = (0, _react.useMemo)(() => /*#__PURE__*/_react.default.createElement(_eui.EuiFormRow, {
    label: _event_filters_list.OS_LABEL,
    fullWidth: true
  }, /*#__PURE__*/_react.default.createElement(_eui.EuiSuperSelect, {
    name: "os",
    options: osOptions,
    fullWidth: true,
    valueOfSelected: selectedOs,
    onChange: handleOnOsChange
  })), [handleOnOsChange, selectedOs]);

  // comments and handler
  const handleOnChangeComment = (0, _react.useCallback)(value => {
    if (!exception) return;
    setNewComment(value);
    processChanged({
      comments: [{
        comment: value
      }]
    });
    if (!hasFormChanged) setHasFormChanged(true);
  }, [exception, hasFormChanged, processChanged]);
  const commentsInputMemo = (0, _react.useMemo)(() => /*#__PURE__*/_react.default.createElement(_item_comments.ExceptionItemComments, {
    exceptionItemComments: existingComments,
    newCommentValue: newComment,
    newCommentOnChange: handleOnChangeComment,
    setCommentError: setHasCommentError
  }), [existingComments, handleOnChangeComment, newComment]);

  // comments
  const commentsSection = (0, _react.useMemo)(() => /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiText, {
    size: "xs"
  }, /*#__PURE__*/_react.default.createElement("h3", null, /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedMessage, {
    id: "xpack.securitySolution.eventFilters.commentsSectionTitle",
    defaultMessage: "Comments"
  }))), /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
    size: "xs"
  }), /*#__PURE__*/_react.default.createElement(_eui.EuiText, {
    size: "s"
  }, /*#__PURE__*/_react.default.createElement("p", null, /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedMessage, {
    id: "xpack.securitySolution.eventFilters.commentsSectionDescription",
    defaultMessage: "Add a comment to your event filter."
  }))), /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
    size: "m"
  }), commentsInputMemo), [commentsInputMemo]);

  // details
  const detailsSection = (0, _react.useMemo)(() => /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiText, {
    size: "xs"
  }, /*#__PURE__*/_react.default.createElement("h3", null, /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedMessage, {
    id: "xpack.securitySolution.eventFilters.detailsSectionTitle",
    defaultMessage: "Details"
  }))), /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
    size: "xs"
  }), /*#__PURE__*/_react.default.createElement(_eui.EuiText, {
    size: "s"
  }, /*#__PURE__*/_react.default.createElement("p", null, _event_filters_list.ABOUT_EVENT_FILTERS)), /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
    size: "m"
  }), nameInputMemo, descriptionInputMemo), [nameInputMemo, descriptionInputMemo]);

  // conditions and handler
  const handleOnBuilderChange = (0, _react.useCallback)(arg => {
    var _arg$exceptionItems$, _exception$name2, _exception$descriptio2, _exception$comments, _exception$os_types2, _exception$tags, _arg$exceptionItems$3, _arg$exceptionItems$4;
    const hasDuplicates = !hasFormChanged && arg.exceptionItems[0] === undefined || (0, _lodash.isEqual)((_arg$exceptionItems$ = arg.exceptionItems[0]) === null || _arg$exceptionItems$ === void 0 ? void 0 : _arg$exceptionItems$.entries, exception === null || exception === void 0 ? void 0 : exception.entries);
    if (hasDuplicates) {
      var _arg$exceptionItems$2;
      const addedFields = ((_arg$exceptionItems$2 = arg.exceptionItems[0]) === null || _arg$exceptionItems$2 === void 0 ? void 0 : _arg$exceptionItems$2.entries.map(e => e.field)) || [''];
      setHasDuplicateFields(computeHasDuplicateFields(getAddedFieldsCounts(addedFields)));
      if (!hasFormChanged) setHasFormChanged(true);
      return;
    }
    const updatedItem = arg.exceptionItems[0] !== undefined ? {
      ...arg.exceptionItems[0],
      name: (_exception$name2 = exception === null || exception === void 0 ? void 0 : exception.name) !== null && _exception$name2 !== void 0 ? _exception$name2 : '',
      description: (_exception$descriptio2 = exception === null || exception === void 0 ? void 0 : exception.description) !== null && _exception$descriptio2 !== void 0 ? _exception$descriptio2 : '',
      comments: (_exception$comments = exception === null || exception === void 0 ? void 0 : exception.comments) !== null && _exception$comments !== void 0 ? _exception$comments : [],
      os_types: (_exception$os_types2 = exception === null || exception === void 0 ? void 0 : exception.os_types) !== null && _exception$os_types2 !== void 0 ? _exception$os_types2 : [_securitysolutionUtils.OperatingSystem.WINDOWS],
      tags: (_exception$tags = exception === null || exception === void 0 ? void 0 : exception.tags) !== null && _exception$tags !== void 0 ? _exception$tags : [],
      meta: exception.meta
    } : exception;
    const hasValidConditions = arg.exceptionItems[0] !== undefined ? !(arg.errorExists && !((_arg$exceptionItems$3 = arg.exceptionItems[0]) !== null && _arg$exceptionItems$3 !== void 0 && (_arg$exceptionItems$4 = _arg$exceptionItems$3.entries) !== null && _arg$exceptionItems$4 !== void 0 && _arg$exceptionItems$4.length)) : false;
    setAreConditionsValid(hasValidConditions);
    processChanged(updatedItem);
    if (!hasFormChanged) setHasFormChanged(true);
  }, [exception, hasFormChanged, processChanged]);
  const exceptionBuilderComponentMemo = (0, _react.useMemo)(() => (0, _public.getExceptionBuilderComponentLazy)({
    allowLargeValueLists: false,
    httpService: http,
    autocompleteService: autocompleteSuggestions,
    exceptionListItems: [eventFilterItem],
    listType: _constants2.EVENT_FILTER_LIST_TYPE,
    listId: _constants2.ENDPOINT_EVENT_FILTERS_LIST_ID,
    listNamespaceType: 'agnostic',
    ruleName: _event_filters_list.RULE_NAME,
    indexPatterns,
    isOrDisabled: true,
    isOrHidden: true,
    isAndDisabled: false,
    isNestedDisabled: false,
    dataTestSubj: 'alert-exception-builder',
    idAria: 'alert-exception-builder',
    onChange: handleOnBuilderChange,
    operatorsList: _securitysolutionListUtils.EVENT_FILTERS_OPERATORS,
    osTypes: exception.os_types
  }), [autocompleteSuggestions, handleOnBuilderChange, http, indexPatterns, exception, eventFilterItem]);

  // conditions
  const criteriaSection = (0, _react.useMemo)(() => /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiText, {
    size: "xs"
  }, /*#__PURE__*/_react.default.createElement("h3", null, /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedMessage, {
    id: "xpack.securitySolution.eventFilters.criteriaSectionTitle",
    defaultMessage: "Conditions"
  }))), /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
    size: "xs"
  }), /*#__PURE__*/_react.default.createElement(_eui.EuiText, {
    size: "s"
  }, /*#__PURE__*/_react.default.createElement("p", null, allowSelectOs ? /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedMessage, {
    id: "xpack.securitySolution.eventFilters.criteriaSectionDescription.withOs",
    defaultMessage: "Select an operating system and add conditions."
  }) : /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedMessage, {
    id: "xpack.securitySolution.eventFilters.criteriaSectionDescription.withoutOs",
    defaultMessage: "Add conditions."
  }))), /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
    size: "m"
  }), allowSelectOs ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, osInputMemo, /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, null)) : null, exceptionBuilderComponentMemo), [allowSelectOs, exceptionBuilderComponentMemo, osInputMemo]);

  // policy and handler
  const handleOnPolicyChange = (0, _react.useCallback)(change => {
    const tags = change.isGlobal ? [_artifacts.GLOBAL_ARTIFACT_TAG] : change.selected.map(policy => `${_artifacts.BY_POLICY_ARTIFACT_TAG_PREFIX}${policy.id}`);

    // Preserve old selected policies when switching to global
    if (!change.isGlobal) {
      setSelectedPolicies(change.selected);
    }
    processChanged({
      tags
    });
    if (!hasFormChanged) setHasFormChanged(true);
  }, [processChanged, hasFormChanged, setSelectedPolicies]);
  const policiesSection = (0, _react.useMemo)(() => /*#__PURE__*/_react.default.createElement(_effected_policy_select.EffectedPolicySelect, {
    selected: selectedPolicies,
    options: policies,
    isGlobal: isGlobal,
    isLoading: policiesIsLoading,
    isPlatinumPlus: isPlatinumPlus,
    onChange: handleOnPolicyChange,
    "data-test-subj": getTestId('effectedPolicies')
  }), [selectedPolicies, policies, isGlobal, policiesIsLoading, isPlatinumPlus, handleOnPolicyChange, getTestId]);
  (0, _react.useEffect)(() => {
    processChanged();
  }, [processChanged]);
  if (isIndexPatternLoading || !exception) {
    return /*#__PURE__*/_react.default.createElement(_loader.Loader, {
      size: "xl"
    });
  }
  return /*#__PURE__*/_react.default.createElement(_eui.EuiForm, {
    component: "div"
  }, detailsSection, /*#__PURE__*/_react.default.createElement(_eui.EuiHorizontalRule, null), criteriaSection, hasDuplicateFields && /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
    size: "xs"
  }), /*#__PURE__*/_react.default.createElement(_eui.EuiText, {
    color: "subdued",
    size: "xs",
    "data-test-subj": "duplicate-fields-warning-message"
  }, /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedMessage, {
    id: "xpack.securitySolution.eventFilters.warningMessage.duplicateFields",
    defaultMessage: "Using multiples of the same filed values can degrade Endpoint performance and/or create ineffective rules"
  }))), showAssignmentSection && /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiHorizontalRule, null), policiesSection), /*#__PURE__*/_react.default.createElement(_eui.EuiHorizontalRule, null), commentsSection);
});
exports.EventFiltersForm = EventFiltersForm;
EventFiltersForm.displayName = 'EventFiltersForm';