"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sourcerer = void 0;
var _eui = require("@elastic/eui");
var _react = _interopRequireWildcard(require("react"));
var _reactRedux = require("react-redux");
var i18n = _interopRequireWildcard(require("./translations"));
var _sourcerer = require("../../store/sourcerer");
var _use_selector = require("../../hooks/use_selector");
var _model = require("../../store/sourcerer/model");
var _use_pick_index_patterns = require("./use_pick_index_patterns");
var _helpers = require("./helpers");
var _temporary = require("./temporary");
var _sourcerer2 = require("../../containers/sourcerer");
var _use_update_data_view = require("./use_update_data_view");
var _trigger = require("./trigger");
var _sub_components = require("./sub_components");
var _use_signal_helpers = require("../../containers/sourcerer/use_signal_helpers");
var _global_query_string = require("../../utils/global_query_string");
var _use_url_state = require("../../hooks/use_url_state");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const Sourcerer = /*#__PURE__*/_react.default.memo(({
  scope: scopeId
}) => {
  const dispatch = (0, _reactRedux.useDispatch)();
  const isDetectionsSourcerer = scopeId === _model.SourcererScopeName.detections;
  const isTimelineSourcerer = scopeId === _model.SourcererScopeName.timeline;
  const isDefaultSourcerer = scopeId === _model.SourcererScopeName.default;
  const updateUrlParam = (0, _global_query_string.useUpdateUrlParam)(_use_url_state.URL_PARAM_KEY.sourcerer);
  const sourcererScopeSelector = (0, _react.useMemo)(() => _sourcerer.sourcererSelectors.getSourcererScopeSelector(), []);
  const {
    defaultDataView,
    kibanaDataViews,
    signalIndexName,
    sourcererScope: {
      selectedDataViewId,
      selectedPatterns,
      missingPatterns: sourcererMissingPatterns
    }
  } = (0, _use_selector.useDeepEqualSelector)(state => sourcererScopeSelector(state, scopeId));
  const {
    pollForSignalIndex
  } = (0, _use_signal_helpers.useSignalHelpers)();
  (0, _react.useEffect)(() => {
    if (pollForSignalIndex != null && (isTimelineSourcerer || isDetectionsSourcerer)) {
      pollForSignalIndex();
    }
  }, [isDetectionsSourcerer, isTimelineSourcerer, pollForSignalIndex]);
  const {
    activePatterns,
    indicesExist,
    loading
  } = (0, _sourcerer2.useSourcererDataView)(scopeId);
  const [missingPatterns, setMissingPatterns] = (0, _react.useState)(activePatterns && activePatterns.length > 0 ? sourcererMissingPatterns.filter(p => activePatterns.includes(p)) : []);
  (0, _react.useEffect)(() => {
    if (activePatterns && activePatterns.length > 0) {
      setMissingPatterns(sourcererMissingPatterns.filter(p => activePatterns.includes(p)));
    }
  }, [activePatterns, sourcererMissingPatterns]);
  const [isOnlyDetectionAlertsChecked, setIsOnlyDetectionAlertsChecked] = (0, _react.useState)(isTimelineSourcerer && selectedPatterns.join() === signalIndexName);
  const onUpdateDetectionAlertsChecked = (0, _react.useCallback)(() => {
    setIsOnlyDetectionAlertsChecked(isTimelineSourcerer && selectedPatterns.join() === signalIndexName);
  }, [isTimelineSourcerer, selectedPatterns, signalIndexName]);
  (0, _react.useEffect)(() => {
    onUpdateDetectionAlertsChecked();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedPatterns]);
  const isOnlyDetectionAlerts = isDetectionsSourcerer || isTimelineSourcerer && isOnlyDetectionAlertsChecked;
  const [isPopoverOpen, setPopoverIsOpen] = (0, _react.useState)(false);
  const [dataViewId, setDataViewId] = (0, _react.useState)(selectedDataViewId);
  const {
    allOptions,
    dataViewSelectOptions,
    loadingIndexPatterns,
    isModified,
    handleOutsideClick,
    onChangeCombo: onChangeIndexPatterns,
    renderOption,
    selectedOptions,
    setIndexPatternsByDataView
  } = (0, _use_pick_index_patterns.usePickIndexPatterns)({
    dataViewId,
    defaultDataViewId: defaultDataView.id,
    isOnlyDetectionAlerts,
    kibanaDataViews,
    missingPatterns,
    scopeId,
    selectedDataViewId,
    selectedPatterns,
    signalIndexName
  });
  const onCheckboxChanged = (0, _react.useCallback)(e => {
    setIsOnlyDetectionAlertsChecked(e.target.checked);
    setDataViewId(defaultDataView.id);
    setIndexPatternsByDataView(defaultDataView.id, e.target.checked);
  }, [defaultDataView.id, setIndexPatternsByDataView]);
  const [expandAdvancedOptions, setExpandAdvancedOptions] = (0, _react.useState)(false);
  const [isShowingUpdateModal, setIsShowingUpdateModal] = (0, _react.useState)(false);
  const setPopoverIsOpenCb = (0, _react.useCallback)(() => {
    setPopoverIsOpen(prevState => !prevState);
    setExpandAdvancedOptions(false); // we always want setExpandAdvancedOptions collapsed by default when popover opened
  }, []);
  const dispatchChangeDataView = (0, _react.useCallback)((newSelectedDataView, newSelectedPatterns, shouldValidateSelectedPatterns) => {
    dispatch(_sourcerer.sourcererActions.setSelectedDataView({
      id: scopeId,
      selectedDataViewId: newSelectedDataView,
      selectedPatterns: newSelectedPatterns,
      shouldValidateSelectedPatterns
    }));
    if (isDefaultSourcerer) {
      updateUrlParam({
        [_model.SourcererScopeName.default]: {
          id: newSelectedDataView,
          selectedPatterns: newSelectedPatterns
        }
      });
    }
  }, [dispatch, scopeId, isDefaultSourcerer, updateUrlParam]);
  const onChangeDataView = (0, _react.useCallback)(newSelectedOption => {
    setDataViewId(newSelectedOption);
    setIndexPatternsByDataView(newSelectedOption);
  }, [setIndexPatternsByDataView]);
  const resetDataSources = (0, _react.useCallback)(() => {
    setDataViewId(defaultDataView.id);
    setIndexPatternsByDataView(defaultDataView.id);
    setIsOnlyDetectionAlertsChecked(false);
    setMissingPatterns([]);
  }, [defaultDataView.id, setIndexPatternsByDataView]);
  const handleSaveIndices = (0, _react.useCallback)(() => {
    const patterns = selectedOptions.map(so => so.label);
    if (dataViewId != null) {
      dispatchChangeDataView(dataViewId, patterns);
    }
    setPopoverIsOpen(false);
  }, [dispatchChangeDataView, dataViewId, selectedOptions]);
  const handleClosePopOver = (0, _react.useCallback)(() => {
    setPopoverIsOpen(false);
    setExpandAdvancedOptions(false);
  }, []);

  // deprecated timeline index pattern handlers
  const onContinueUpdateDeprecated = (0, _react.useCallback)(() => {
    setIsShowingUpdateModal(false);
    const patterns = selectedPatterns.filter(pattern => defaultDataView.patternList.includes(pattern));
    dispatchChangeDataView(defaultDataView.id, patterns);
    setPopoverIsOpen(false);
  }, [defaultDataView.id, defaultDataView.patternList, dispatchChangeDataView, selectedPatterns]);
  const onUpdateDeprecated = (0, _react.useCallback)(() => {
    // are all the patterns in the default?
    if (missingPatterns.length === 0) {
      onContinueUpdateDeprecated();
    } else {
      // open modal
      setIsShowingUpdateModal(true);
    }
  }, [missingPatterns, onContinueUpdateDeprecated]);
  const [isTriggerDisabled, setIsTriggerDisabled] = (0, _react.useState)(false);
  const onOpenAndReset = (0, _react.useCallback)(() => {
    setPopoverIsOpen(true);
    resetDataSources();
  }, [resetDataSources]);
  const updateDataView = (0, _use_update_data_view.useUpdateDataView)(onOpenAndReset);
  const onUpdateDataView = (0, _react.useCallback)(async () => {
    const isUiSettingsSuccess = await updateDataView(missingPatterns);
    setIsShowingUpdateModal(false);
    setPopoverIsOpen(false);
    if (isUiSettingsSuccess) {
      dispatchChangeDataView(defaultDataView.id, // to be at this stage, activePatterns is defined, the ?? selectedPatterns is to make TS happy
      activePatterns !== null && activePatterns !== void 0 ? activePatterns : selectedPatterns, false);
      setIsTriggerDisabled(true);
    }
  }, [activePatterns, defaultDataView.id, missingPatterns, dispatchChangeDataView, selectedPatterns, updateDataView]);
  (0, _react.useEffect)(() => {
    setDataViewId(selectedDataViewId);
  }, [selectedDataViewId]);
  const onOutsideClick = (0, _react.useCallback)(() => {
    setDataViewId(selectedDataViewId);
    setMissingPatterns(sourcererMissingPatterns);
    onUpdateDetectionAlertsChecked();
    handleOutsideClick();
  }, [handleOutsideClick, onUpdateDetectionAlertsChecked, selectedDataViewId, sourcererMissingPatterns]);
  const onExpandAdvancedOptionsClicked = (0, _react.useCallback)(() => {
    setExpandAdvancedOptions(prevState => !prevState);
  }, []);

  // always show sourcerer in timeline
  return indicesExist || scopeId === _model.SourcererScopeName.timeline ? /*#__PURE__*/_react.default.createElement(_eui.EuiPopover, {
    panelClassName: "sourcererPopoverPanel",
    button: /*#__PURE__*/_react.default.createElement(_trigger.Trigger, {
      activePatterns: activePatterns,
      disabled: isTriggerDisabled,
      isModified: isModified,
      isOnlyDetectionAlerts: isOnlyDetectionAlerts,
      isPopoverOpen: isPopoverOpen,
      isTimelineSourcerer: isTimelineSourcerer,
      loading: loading,
      onClick: setPopoverIsOpenCb,
      selectedPatterns: selectedPatterns,
      signalIndexName: signalIndexName
    }),
    closePopover: handleClosePopOver,
    "data-test-subj": isTimelineSourcerer ? 'timeline-sourcerer-popover' : 'sourcerer-popover',
    display: "block",
    isOpen: isPopoverOpen,
    ownFocus: true,
    repositionOnScroll: true
  }, /*#__PURE__*/_react.default.createElement(_eui.EuiOutsideClickDetector, {
    onOutsideClick: onOutsideClick
  }, /*#__PURE__*/_react.default.createElement(_helpers.PopoverContent, null, /*#__PURE__*/_react.default.createElement(_eui.EuiPopoverTitle, {
    "data-test-subj": "sourcerer-title"
  }, /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, i18n.SELECT_DATA_VIEW)), /*#__PURE__*/_react.default.createElement(_sub_components.SourcererCallout, {
    isOnlyDetectionAlerts: isOnlyDetectionAlerts,
    title: isTimelineSourcerer ? i18n.CALL_OUT_TIMELINE_TITLE : i18n.CALL_OUT_TITLE
  }), /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
    size: "s"
  }), dataViewId === null && isModified === 'deprecated' || isModified === 'missingPatterns' ? /*#__PURE__*/_react.default.createElement(_temporary.TemporarySourcerer, {
    activePatterns: activePatterns,
    indicesExist: indicesExist,
    isModified: isModified,
    isShowingUpdateModal: isShowingUpdateModal,
    missingPatterns: missingPatterns,
    onContinueWithoutUpdate: onContinueUpdateDeprecated,
    onDismiss: setPopoverIsOpenCb,
    onDismissModal: () => setIsShowingUpdateModal(false),
    onReset: resetDataSources,
    onUpdateStepOne: isModified === 'deprecated' ? onUpdateDeprecated : onUpdateDataView,
    onUpdateStepTwo: onUpdateDataView,
    selectedPatterns: selectedPatterns
  }) : /*#__PURE__*/_react.default.createElement(_eui.EuiForm, {
    component: "form"
  }, /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_sub_components.AlertsCheckbox, {
    isShow: isTimelineSourcerer,
    checked: isOnlyDetectionAlertsChecked,
    onChange: onCheckboxChanged
  }), dataViewId && /*#__PURE__*/_react.default.createElement(_helpers.StyledFormRow, {
    label: i18n.INDEX_PATTERNS_CHOOSE_DATA_VIEW_LABEL
  }, /*#__PURE__*/_react.default.createElement(_eui.EuiSuperSelect, {
    "data-test-subj": "sourcerer-select",
    isLoading: loadingIndexPatterns,
    disabled: isOnlyDetectionAlerts,
    fullWidth: true,
    onChange: onChangeDataView,
    options: dataViewSelectOptions,
    placeholder: i18n.INDEX_PATTERNS_CHOOSE_DATA_VIEW_LABEL,
    valueOfSelected: dataViewId
  })), /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
    size: "m"
  }), /*#__PURE__*/_react.default.createElement(_helpers.StyledButtonEmpty, {
    color: "text",
    "data-test-subj": "sourcerer-advanced-options-toggle",
    iconType: expandAdvancedOptions ? 'arrowDown' : 'arrowRight',
    onClick: onExpandAdvancedOptionsClicked
  }, i18n.INDEX_PATTERNS_ADVANCED_OPTIONS_TITLE), expandAdvancedOptions && /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
    size: "m"
  }), /*#__PURE__*/_react.default.createElement(_helpers.FormRow, {
    isDisabled: loadingIndexPatterns,
    $expandAdvancedOptions: expandAdvancedOptions,
    helpText: isOnlyDetectionAlerts ? undefined : i18n.INDEX_PATTERNS_DESCRIPTIONS,
    label: i18n.INDEX_PATTERNS_LABEL
  }, /*#__PURE__*/_react.default.createElement(_eui.EuiComboBox, {
    "data-test-subj": "sourcerer-combo-box",
    fullWidth: true,
    isDisabled: isOnlyDetectionAlerts || loadingIndexPatterns,
    onChange: onChangeIndexPatterns,
    options: allOptions,
    placeholder: i18n.PICK_INDEX_PATTERNS,
    renderOption: renderOption,
    selectedOptions: selectedOptions
  })), /*#__PURE__*/_react.default.createElement(_sub_components.SaveButtons, {
    disableSave: selectedOptions.length === 0,
    isShow: !isDetectionsSourcerer,
    onReset: resetDataSources,
    onSave: handleSaveIndices
  })), /*#__PURE__*/_react.default.createElement(_eui.EuiSpacer, {
    size: "s"
  }))))) : null;
});
exports.Sourcerer = Sourcerer;
Sourcerer.displayName = 'Sourcerer';