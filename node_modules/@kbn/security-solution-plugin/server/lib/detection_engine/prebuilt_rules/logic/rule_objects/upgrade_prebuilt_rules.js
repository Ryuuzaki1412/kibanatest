"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.upgradePrebuiltRules = void 0;
var _constants = require("../../../../../../common/constants");
var _transform_actions = require("../../../../../../common/detection_engine/transform_actions");
var _promise_pool = require("../../../../../utils/promise_pool");
var _with_security_span = require("../../../../../utils/with_security_span");
var _create_rules = require("../../../rule_management/logic/crud/create_rules");
var _delete_rules = require("../../../rule_management/logic/crud/delete_rules");
var _patch_rules = require("../../../rule_management/logic/crud/patch_rules");
var _read_rules = require("../../../rule_management/logic/crud/read_rules");
var _install_prebuilt_rules_and_timelines_route = require("../../api/install_prebuilt_rules_and_timelines/install_prebuilt_rules_and_timelines_route");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

/**
 * Upgrades existing prebuilt rules given a set of rules and output index.
 * This implements a chunked approach to not saturate network connections and
 * avoid being a "noisy neighbor".
 * @param rulesClient Alerting client
 * @param rules The rules to apply the update for
 */
const upgradePrebuiltRules = async (rulesClient, rules) => (0, _with_security_span.withSecuritySpan)('upgradePrebuiltRules', async () => {
  const result = await (0, _promise_pool.initPromisePool)({
    concurrency: _constants.MAX_RULES_TO_UPDATE_IN_PARALLEL,
    items: rules,
    executor: async rule => {
      return upgradeRule(rulesClient, rule);
    }
  });
  return result;
});

/**
 * Upgrades a rule
 *
 * @param rulesClient Alerting client
 * @param rule The rule to apply the update for
 * @returns Promise of what was updated.
 */
exports.upgradePrebuiltRules = upgradePrebuiltRules;
const upgradeRule = async (rulesClient, rule) => {
  const existingRule = await (0, _read_rules.readRules)({
    rulesClient,
    ruleId: rule.rule_id,
    id: undefined
  });
  if (!existingRule) {
    throw new _install_prebuilt_rules_and_timelines_route.PrepackagedRulesError(`Failed to find rule ${rule.rule_id}`, 500);
  }

  // If we're trying to change the type of a prepackaged rule, we need to delete the old one
  // and replace it with the new rule, keeping the enabled setting, actions, throttle, id,
  // and exception lists from the old rule
  if (rule.type !== existingRule.params.type) {
    await (0, _delete_rules.deleteRules)({
      ruleId: existingRule.id,
      rulesClient
    });
    return (0, _create_rules.createRules)({
      rulesClient,
      immutable: true,
      id: existingRule.id,
      params: {
        ...rule,
        // Force the prepackaged rule to use the enabled state from the existing rule,
        // regardless of what the prepackaged rule says
        enabled: existingRule.enabled,
        exceptions_list: existingRule.params.exceptionsList,
        actions: existingRule.actions.map(_transform_actions.transformAlertToRuleAction),
        timeline_id: existingRule.params.timelineId,
        timeline_title: existingRule.params.timelineTitle
      }
    });
  }
  await (0, _patch_rules.patchRules)({
    rulesClient,
    existingRule,
    nextParams: {
      ...rule,
      // Force enabled to use the enabled state from the existing rule by passing in undefined to patchRules
      enabled: undefined
    }
  });
  const updatedRule = await (0, _read_rules.readRules)({
    rulesClient,
    ruleId: rule.rule_id,
    id: undefined
  });
  if (!updatedRule) {
    throw new _install_prebuilt_rules_and_timelines_route.PrepackagedRulesError(`Rule ${rule.rule_id} not found after upgrade`, 500);
  }
  return updatedRule;
};