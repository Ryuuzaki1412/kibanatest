"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AbstractDataView = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _lodash = require("lodash");
var _utils = require("./utils");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

class AbstractDataView {
  /**
   * Saved object id
   */

  /**
   * Title of data view
   * @deprecated use getIndexPattern instead
   */

  /**
   * Map of field formats by field name
   */

  /**
   * Only used by rollup indices, used by rollup specific endpoint to load field list.
   */

  /**
   * Timestamp field name
   */

  /**
   * Type is used to identify rollup index patterns.
   */

  /**
   * List of meta fields by name
   */

  /**
   * SavedObject version
   */

  /**
   * Array of filters - hides fields in discover
   */

  /**
   * Array of namespace ids
   */

  /**
   * Original saved object body. Used to check for saved object changes.
   */

  /**
   * Returns true if short dot notation is enabled
   */

  /**
   * FieldFormats service interface
   */

  /**
   * Map of field attributes by field name. Currently count and customLabel.
   */

  /**
   * Map of runtime field definitions by field name
   */

  /**
   * Prevents errors when index pattern exists before indices
   */

  /**
   * Name of the data view. Human readable name used to differentiate data view.
   */

  /*
   * list of indices that the index pattern matched
   */

  constructor(config) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "title", '');
    (0, _defineProperty2.default)(this, "fieldFormatMap", void 0);
    (0, _defineProperty2.default)(this, "typeMeta", void 0);
    (0, _defineProperty2.default)(this, "timeFieldName", void 0);
    (0, _defineProperty2.default)(this, "type", void 0);
    (0, _defineProperty2.default)(this, "metaFields", void 0);
    (0, _defineProperty2.default)(this, "version", void 0);
    (0, _defineProperty2.default)(this, "sourceFilters", void 0);
    (0, _defineProperty2.default)(this, "namespaces", void 0);
    (0, _defineProperty2.default)(this, "originalSavedObjectBody", {});
    (0, _defineProperty2.default)(this, "shortDotsEnable", false);
    (0, _defineProperty2.default)(this, "fieldFormats", void 0);
    (0, _defineProperty2.default)(this, "fieldAttrs", void 0);
    (0, _defineProperty2.default)(this, "runtimeFieldMap", void 0);
    (0, _defineProperty2.default)(this, "allowNoIndex", false);
    (0, _defineProperty2.default)(this, "name", '');
    (0, _defineProperty2.default)(this, "matchedIndices", []);
    (0, _defineProperty2.default)(this, "scriptedFields", void 0);
    (0, _defineProperty2.default)(this, "allowHidden", false);
    (0, _defineProperty2.default)(this, "getAllowHidden", () => this.allowHidden);
    (0, _defineProperty2.default)(this, "setAllowHidden", allowHidden => this.allowHidden = allowHidden);
    /**
     * Get name of Data View
     */
    (0, _defineProperty2.default)(this, "getName", () => this.name ? this.name : this.title);
    /**
     * Get index pattern
     * @returns index pattern string
     */
    (0, _defineProperty2.default)(this, "getIndexPattern", () => this.title);
    /**
     * Set index pattern
     * @param string index pattern string
     */
    (0, _defineProperty2.default)(this, "setIndexPattern", indexPattern => {
      this.title = indexPattern;
    });
    /**
     * Get last saved saved object fields
     */
    (0, _defineProperty2.default)(this, "getOriginalSavedObjectBody", () => ({
      ...this.originalSavedObjectBody
    }));
    /**
     * Reset last saved saved object fields. Used after saving.
     */
    (0, _defineProperty2.default)(this, "resetOriginalSavedObjectBody", () => {
      this.originalSavedObjectBody = this.getAsSavedObjectBody();
    });
    /**
     * Set field formatter
     * @param fieldName name of field to set format on
     * @param format field format in serialized form
     */
    (0, _defineProperty2.default)(this, "setFieldFormat", (fieldName, format) => {
      this.fieldFormatMap[fieldName] = format;
    });
    /**
     * Remove field format from the field format map.
     * @param fieldName field name associated with the format for removal
     */
    (0, _defineProperty2.default)(this, "deleteFieldFormat", fieldName => {
      delete this.fieldFormatMap[fieldName];
    });
    (0, _defineProperty2.default)(this, "upsertScriptedFieldInternal", field => {
      // search for scriped field with same name
      const findByName = f => f.name === field.name;
      const fieldIndex = (0, _lodash.findIndex)(this.scriptedFields, findByName);
      const scriptedField = {
        name: field.name,
        script: field.script,
        lang: field.lang,
        type: field.type,
        scripted: field.scripted
      };
      if (fieldIndex === -1) {
        this.scriptedFields.push(scriptedField);
      } else {
        this.scriptedFields[fieldIndex] = scriptedField;
      }
    });
    (0, _defineProperty2.default)(this, "deleteScriptedFieldInternal", fieldName => {
      this.scriptedFields = this.scriptedFields.filter(field => field.name !== fieldName);
    });
    (0, _defineProperty2.default)(this, "getFieldAttrs", () => (0, _lodash.cloneDeep)(this.fieldAttrs));
    const {
      spec = {},
      fieldFormats,
      shortDotsEnable = false,
      metaFields = []
    } = config;
    const extractedFieldAttrs = spec !== null && spec !== void 0 && spec.fields ? Object.entries(spec.fields).reduce((acc, [key, value]) => {
      const attrs = {};
      let hasAttrs = false;
      if (value.count) {
        attrs.count = value.count;
        hasAttrs = true;
      }
      if (value.customLabel) {
        attrs.customLabel = value.customLabel;
        hasAttrs = true;
      }
      if (hasAttrs) {
        acc[key] = attrs;
      }
      return acc;
    }, {}) : [];
    this.allowNoIndex = (spec === null || spec === void 0 ? void 0 : spec.allowNoIndex) || false;
    // CRUD operations on scripted fields need to be examined
    this.scriptedFields = spec !== null && spec !== void 0 && spec.fields ? Object.values(spec.fields).filter(field => field.scripted) : [];

    // set dependencies
    this.fieldFormats = {
      ...fieldFormats
    };
    // set config
    this.shortDotsEnable = shortDotsEnable;
    this.metaFields = metaFields;

    // set values
    this.id = spec.id;
    this.fieldFormatMap = {
      ...spec.fieldFormats
    };
    this.version = spec.version;
    this.title = spec.title || '';
    this.timeFieldName = spec.timeFieldName;
    this.sourceFilters = [...(spec.sourceFilters || [])];
    this.type = spec.type;
    this.typeMeta = spec.typeMeta;
    this.fieldAttrs = (0, _lodash.cloneDeep)((0, _lodash.merge)({}, extractedFieldAttrs, spec.fieldAttrs)) || {};
    this.runtimeFieldMap = (0, _lodash.cloneDeep)(spec.runtimeFieldMap) || {};
    this.namespaces = spec.namespaces || [];
    this.name = spec.name || '';
    this.allowHidden = spec.allowHidden || false;
  }
  isPersisted() {
    return typeof this.version === 'string';
  }

  /**
   * Get the source filtering configuration for that index.
   */
  getSourceFiltering() {
    return {
      excludes: this.sourceFilters && this.sourceFilters.map(filter => filter.value) || []
    };
  }

  /**
   * Get aggregation restrictions. Rollup fields can only perform a subset of aggregations.
   */

  getAggregationRestrictions() {
    var _this$typeMeta;
    return (_this$typeMeta = this.typeMeta) === null || _this$typeMeta === void 0 ? void 0 : _this$typeMeta.aggs;
  }

  /**
   * Provide a field, get its formatter
   * @param field field to get formatter for
   */
  getFormatterForField(field) {
    const fieldFormat = this.getFormatterForFieldNoDefault(field.name);
    if (fieldFormat) {
      return fieldFormat;
    }
    return this.fieldFormats.getDefaultInstance(field.type, field.esTypes);
  }

  /**
   * Get formatter for a given field name. Return undefined if none exists.
   * @param fieldname name of field to get formatter for
   */
  getFormatterForFieldNoDefault(fieldname) {
    const formatSpec = this.fieldFormatMap[fieldname];
    if (formatSpec !== null && formatSpec !== void 0 && formatSpec.id) {
      return this.fieldFormats.getInstance(formatSpec.id, formatSpec.params);
    }
  }

  /**
   * Set field attribute
   * @param fieldName name of field to set attribute on
   * @param attrName name of attribute to set
   * @param value value of attribute
   */

  setFieldAttrs(fieldName, attrName, value) {
    if (!this.fieldAttrs[fieldName]) {
      this.fieldAttrs[fieldName] = {};
    }
    this.fieldAttrs[fieldName][attrName] = value;
  }

  /**
   * Set field custom label
   * @param fieldName name of field to set custom label on
   * @param customLabel custom label value. If undefined, custom label is removed
   */

  setFieldCustomLabelInternal(fieldName, customLabel) {
    this.setFieldAttrs(fieldName, 'customLabel', customLabel === null ? undefined : customLabel);
  }
  /**
   * Returns index pattern as saved object body for saving
   */
  getAsSavedObjectBody() {
    const stringifyOrUndefined = obj => obj ? JSON.stringify(obj) : undefined;
    return {
      fieldAttrs: stringifyOrUndefined(this.fieldAttrs),
      title: this.getIndexPattern(),
      timeFieldName: this.timeFieldName,
      sourceFilters: stringifyOrUndefined(this.sourceFilters),
      fields: stringifyOrUndefined(this.scriptedFields),
      fieldFormatMap: stringifyOrUndefined(this.fieldFormatMap),
      type: this.type,
      typeMeta: stringifyOrUndefined(this.typeMeta),
      allowNoIndex: this.allowNoIndex ? this.allowNoIndex : undefined,
      runtimeFieldMap: stringifyOrUndefined(this.runtimeFieldMap),
      name: this.name,
      allowHidden: this.allowHidden
    };
  }
  /**
   * Checks if runtime field exists
   * @param name field name
   */
  hasRuntimeField(name) {
    return !!this.runtimeFieldMap[name];
  }

  /**
   * Returns runtime field if exists
   * @param name Runtime field name
   */
  getRuntimeField(name) {
    if (!this.runtimeFieldMap[name]) {
      return null;
    }
    const {
      type,
      script,
      fields
    } = {
      ...this.runtimeFieldMap[name]
    };
    const runtimeField = {
      type,
      script
    };
    if (type === 'composite') {
      runtimeField.fields = fields;
    }
    return runtimeField;
  }

  /**
   * Get all runtime field definitions.
   * NOTE: this does not strip out runtime fields that match mapped field names
   * @returns map of runtime field definitions by field name
   */

  getAllRuntimeFields() {
    return Object.keys(this.runtimeFieldMap).reduce((acc, fieldName) => ({
      ...acc,
      [fieldName]: this.getRuntimeField(fieldName)
    }), {});
  }
  removeRuntimeFieldInteral(name) {
    delete this.runtimeFieldMap[name];
  }
  addRuntimeFieldInteral(name, runtimeField) {
    this.runtimeFieldMap[name] = (0, _utils.removeFieldAttrs)(runtimeField);
  }
}
exports.AbstractDataView = AbstractDataView;