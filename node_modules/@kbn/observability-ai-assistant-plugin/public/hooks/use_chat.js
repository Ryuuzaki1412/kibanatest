"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChatState = void 0;
exports.useChat = useChat;
var _i18n = require("@kbn/i18n");
var _lodash = require("lodash");
var _react = require("react");
var _common = require("../../common");
var _conversation_complete = require("../../common/conversation_complete");
var _get_assistant_setup_message = require("../service/get_assistant_setup_message");
var _use_kibana = require("./use_kibana");
var _use_once = require("./use_once");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */
let ChatState;
exports.ChatState = ChatState;
(function (ChatState) {
  ChatState["Ready"] = "ready";
  ChatState["Loading"] = "loading";
  ChatState["Error"] = "error";
  ChatState["Aborted"] = "aborted";
})(ChatState || (exports.ChatState = ChatState = {}));
function getWithSystemMessage(messages, systemMessage) {
  return [systemMessage, ...messages.filter(message => message.message.role !== _common.MessageRole.System)];
}
function useChat({
  initialMessages,
  initialConversationId,
  chatService,
  connectorId,
  onConversationUpdate,
  onChatComplete,
  persist
}) {
  const [chatState, setChatState] = (0, _react.useState)(ChatState.Ready);
  const systemMessage = (0, _react.useMemo)(() => {
    return (0, _get_assistant_setup_message.getAssistantSetupMessage)({
      contexts: chatService.getContexts()
    });
  }, [chatService]);
  (0, _use_once.useOnce)(initialMessages);
  (0, _use_once.useOnce)(initialConversationId);
  const [conversationId, setConversationId] = (0, _react.useState)(initialConversationId);
  const [messages, setMessages] = (0, _react.useState)(initialMessages);
  const [pendingMessages, setPendingMessages] = (0, _react.useState)();
  const abortControllerRef = (0, _react.useRef)(new AbortController());
  const {
    services: {
      notifications
    }
  } = (0, _use_kibana.useKibana)();
  const onChatCompleteRef = (0, _react.useRef)(onChatComplete);
  onChatCompleteRef.current = onChatComplete;
  const onConversationUpdateRef = (0, _react.useRef)(onConversationUpdate);
  onConversationUpdateRef.current = onConversationUpdate;
  const handleSignalAbort = (0, _react.useCallback)(() => {
    setChatState(ChatState.Aborted);
  }, []);
  const handleError = (0, _react.useCallback)(error => {
    notifications.toasts.addError(error, {
      title: _i18n.i18n.translate('xpack.observabilityAiAssistant.failedToLoadResponse', {
        defaultMessage: 'Failed to load response from the AI Assistant'
      })
    });
    setChatState(ChatState.Error);
  }, [notifications.toasts]);
  const next = (0, _react.useCallback)(async nextMessages => {
    // make sure we ignore any aborts for the previous signal
    abortControllerRef.current.signal.removeEventListener('abort', handleSignalAbort);

    // cancel running requests
    abortControllerRef.current.abort();
    abortControllerRef.current = new AbortController();
    setPendingMessages([]);
    setMessages(nextMessages);
    if (!connectorId || !nextMessages.length) {
      setChatState(ChatState.Ready);
      return;
    }
    setChatState(ChatState.Loading);
    const next$ = chatService.complete({
      connectorId,
      messages: getWithSystemMessage(nextMessages, systemMessage),
      persist,
      signal: abortControllerRef.current.signal,
      conversationId
    });
    function getPendingMessages() {
      return [...completedMessages, ...(pendingMessage ? [(0, _lodash.merge)({
        message: {
          role: _common.MessageRole.Assistant,
          function_call: {
            trigger: _common.MessageRole.Assistant
          }
        }
      }, pendingMessage)] : [])];
    }
    const completedMessages = [];
    let pendingMessage;
    const subscription = next$.subscribe({
      next: event => {
        var _onConversationUpdate, _onConversationUpdate2;
        switch (event.type) {
          case _conversation_complete.StreamingChatResponseEventType.ChatCompletionChunk:
            if (!pendingMessage) {
              var _event$message$functi, _event$message$functi2;
              pendingMessage = {
                '@timestamp': new Date().toISOString(),
                message: {
                  content: event.message.content || '',
                  function_call: {
                    name: ((_event$message$functi = event.message.function_call) === null || _event$message$functi === void 0 ? void 0 : _event$message$functi.name) || '',
                    arguments: ((_event$message$functi2 = event.message.function_call) === null || _event$message$functi2 === void 0 ? void 0 : _event$message$functi2.arguments) || ''
                  }
                }
              };
            } else {
              var _event$message$functi3, _event$message$functi4;
              pendingMessage.message.content += event.message.content || '';
              pendingMessage.message.function_call.name += ((_event$message$functi3 = event.message.function_call) === null || _event$message$functi3 === void 0 ? void 0 : _event$message$functi3.name) || '';
              pendingMessage.message.function_call.arguments += ((_event$message$functi4 = event.message.function_call) === null || _event$message$functi4 === void 0 ? void 0 : _event$message$functi4.arguments) || '';
            }
            break;
          case _conversation_complete.StreamingChatResponseEventType.MessageAdd:
            pendingMessage = undefined;
            completedMessages.push(event.message);
            break;
          case _conversation_complete.StreamingChatResponseEventType.ConversationCreate:
            setConversationId(event.conversation.id);
            (_onConversationUpdate = onConversationUpdateRef.current) === null || _onConversationUpdate === void 0 ? void 0 : _onConversationUpdate.call(onConversationUpdateRef, event);
            break;
          case _conversation_complete.StreamingChatResponseEventType.ConversationUpdate:
            (_onConversationUpdate2 = onConversationUpdateRef.current) === null || _onConversationUpdate2 === void 0 ? void 0 : _onConversationUpdate2.call(onConversationUpdateRef, event);
            break;
        }
        setPendingMessages(getPendingMessages());
      },
      complete: () => {
        var _onChatCompleteRef$cu;
        setChatState(ChatState.Ready);
        const completed = nextMessages.concat(completedMessages);
        setMessages(completed);
        setPendingMessages([]);
        (_onChatCompleteRef$cu = onChatCompleteRef.current) === null || _onChatCompleteRef$cu === void 0 ? void 0 : _onChatCompleteRef$cu.call(onChatCompleteRef, completed);
      },
      error: error => {
        setPendingMessages([]);
        setMessages(nextMessages.concat(getPendingMessages()));
        handleError(error);
      }
    });
    abortControllerRef.current.signal.addEventListener('abort', () => {
      handleSignalAbort();
      subscription.unsubscribe();
    });
  }, [connectorId, chatService, handleSignalAbort, systemMessage, handleError, persist, conversationId]);
  (0, _react.useEffect)(() => {
    return () => {
      abortControllerRef.current.abort();
    };
  }, []);
  const memoizedMessages = (0, _react.useMemo)(() => {
    return getWithSystemMessage(messages.concat(pendingMessages !== null && pendingMessages !== void 0 ? pendingMessages : []), systemMessage);
  }, [systemMessage, messages, pendingMessages]);
  const setMessagesWithAbort = (0, _react.useCallback)(nextMessages => {
    abortControllerRef.current.abort();
    setPendingMessages([]);
    setChatState(ChatState.Ready);
    setMessages(nextMessages);
  }, []);
  return {
    messages: memoizedMessages,
    setMessages: setMessagesWithAbort,
    state: chatState,
    next,
    stop: () => {
      abortControllerRef.current.abort();
    }
  };
}