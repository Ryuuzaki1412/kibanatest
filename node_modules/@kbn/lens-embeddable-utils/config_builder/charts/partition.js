"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildPartitionChart = buildPartitionChart;
var _types = require("../types");
var _utils = require("../utils");
var _columns = require("../columns");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

const ACCESSOR = 'metric_formula_accessor';
function buildVisualizationState(config) {
  const layer = config;
  const layerBreakdown = Array.isArray(layer.breakdown) ? layer.breakdown : [layer.breakdown];
  let legendDisplay = 'default';
  let legendPosition = 'right';
  if ('legend' in config && config.legend) {
    if ('show' in config.legend) {
      legendDisplay = config.legend ? 'show' : 'hide';
    }
    legendPosition = config.legend.position || 'right';
  }
  return {
    shape: config.chartType,
    layers: [{
      layerId: _types.DEFAULT_LAYER_ID,
      layerType: 'data',
      metrics: [ACCESSOR],
      allowMultipleMetrics: false,
      numberDisplay: 'percent',
      categoryDisplay: 'default',
      legendDisplay,
      legendPosition,
      primaryGroups: layerBreakdown.map((breakdown, i) => `${ACCESSOR}_breakdown_${i}`)
    }]
  };
}
function buildFormulaLayer(layer, layerNr, dataView, formulaAPI) {
  const layers = {
    [_types.DEFAULT_LAYER_ID]: {
      ...(0, _columns.getFormulaColumn)(ACCESSOR, {
        value: layer.value
      }, dataView, formulaAPI)
    }
  };
  const defaultLayer = layers[_types.DEFAULT_LAYER_ID];
  if (layer.breakdown) {
    const layerBreakdown = Array.isArray(layer.breakdown) ? layer.breakdown : [layer.breakdown];
    layerBreakdown.reverse().forEach((breakdown, i) => {
      const columnName = `${ACCESSOR}_breakdown_${i}`;
      const breakdownColumn = (0, _columns.getBreakdownColumn)({
        options: breakdown,
        dataView
      });
      (0, _utils.addLayerColumn)(defaultLayer, columnName, breakdownColumn, true);
    });
  } else {
    throw new Error('breakdown must be defined!');
  }
  return defaultLayer;
}
function getValueColumns(layer) {
  if (layer.breakdown && layer.breakdown.filter(b => typeof b !== 'string').length) {
    throw new Error('breakdown must be a field name when not using index source');
  }
  return [...(layer.breakdown ? layer.breakdown.map((b, i) => {
    return (0, _columns.getValueColumn)(`${ACCESSOR}_breakdown_${i}`, b);
  }) : []), (0, _columns.getValueColumn)(ACCESSOR, layer.value)];
}
async function buildPartitionChart(config, {
  dataViewsAPI,
  formulaAPI
}) {
  const dataviews = {};
  const _buildFormulaLayer = (cfg, i, dataView) => buildFormulaLayer(cfg, i, dataView, formulaAPI);
  const datasourceStates = await (0, _utils.buildDatasourceStates)(config, dataviews, _buildFormulaLayer, getValueColumns, dataViewsAPI);
  return {
    title: config.title,
    visualizationType: 'lnsPie',
    references: (0, _utils.buildReferences)(dataviews),
    state: {
      datasourceStates,
      internalReferences: [],
      filters: [],
      query: {
        language: 'kuery',
        query: ''
      },
      visualization: buildVisualizationState(config),
      // Getting the spec from a data view is a heavy operation, that's why the result is cached.
      adHocDataViews: (0, _utils.getAdhocDataviews)(dataviews)
    }
  };
}