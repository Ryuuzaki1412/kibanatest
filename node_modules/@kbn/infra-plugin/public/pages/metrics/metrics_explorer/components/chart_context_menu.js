"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MetricsExplorerChartContextMenu = void 0;
var _react = _interopRequireWildcard(require("react"));
var _i18n = require("@kbn/i18n");
var _eui = require("@elastic/eui");
var _datemath = _interopRequireDefault(require("@kbn/datemath"));
var _public = require("@kbn/observability-shared-plugin/public");
var _alert_flyout = require("../../../../alerting/metric_threshold/components/alert_flyout");
var _create_tsvb_link = require("./helpers/create_tsvb_link");
var _link_to = require("../../../link_to");
var _constants = require("../../../../../common/constants");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

const fieldToNodeType = (source, groupBy) => {
  const fields = Array.isArray(groupBy) ? groupBy : [groupBy];
  if (fields.includes(_constants.HOST_FIELD)) {
    return 'host';
  }
  if (fields.includes(_constants.POD_FIELD)) {
    return 'pod';
  }
  if (fields.includes(_constants.CONTAINER_FIELD)) {
    return 'container';
  }
};
const dateMathExpressionToEpoch = (dateMathExpression, roundUp = false) => {
  const dateObj = _datemath.default.parse(dateMathExpression, {
    roundUp
  });
  if (!dateObj) throw new Error(`"${dateMathExpression}" is not a valid time string`);
  return dateObj.valueOf();
};
const MetricsExplorerChartContextMenu = ({
  onFilter,
  options,
  series,
  source,
  timeRange,
  uiCapabilities,
  chartOptions
}) => {
  var _uiCapabilities$visua, _uiCapabilities$infra;
  const {
    getNodeDetailUrl
  } = (0, _link_to.useNodeDetailsRedirect)();
  const [isPopoverOpen, setPopoverState] = (0, _react.useState)(false);
  const [flyoutVisible, setFlyoutVisible] = (0, _react.useState)(false);
  const supportFiltering = options.groupBy != null && onFilter != null;
  const handleFilter = (0, _react.useCallback)(() => {
    // onFilter needs check for Typescript even though it's
    // covered by supportFiltering variable
    if (supportFiltering && onFilter) {
      if (Array.isArray(options.groupBy)) {
        onFilter(options.groupBy.map((field, index) => {
          var _series$keys;
          return `${field}: "${(_series$keys = series.keys) === null || _series$keys === void 0 ? void 0 : _series$keys[index]}"`;
        }).join(' and '));
      } else {
        onFilter(`${options.groupBy}: "${series.id}"`);
      }
    }
    setPopoverState(false);
  }, [supportFiltering, onFilter, options, series.keys, series.id]);

  // Only display the "Add Filter" option if it's supported
  const filterByItem = supportFiltering ? [{
    name: _i18n.i18n.translate('xpack.infra.metricsExplorer.filterByLabel', {
      defaultMessage: 'Add filter'
    }),
    icon: 'metricsApp',
    onClick: handleFilter,
    'data-test-subj': 'metricsExplorerAction-AddFilter'
  }] : [];
  const nodeType = source && options.groupBy && fieldToNodeType(source, options.groupBy);
  const nodeDetailLinkProps = (0, _public.useLinkProps)({
    app: 'metrics',
    ...(nodeType ? getNodeDetailUrl({
      assetType: nodeType,
      assetId: series.id,
      search: {
        from: dateMathExpressionToEpoch(timeRange.from),
        to: dateMathExpressionToEpoch(timeRange.to, true)
      }
    }) : {})
  });
  const tsvbLinkProps = (0, _public.useLinkProps)({
    ...(0, _create_tsvb_link.createTSVBLink)(source, options, series, timeRange, chartOptions)
  });
  const viewNodeDetail = nodeType ? [{
    name: _i18n.i18n.translate('xpack.infra.metricsExplorer.viewNodeDetail', {
      defaultMessage: 'View metrics for {name}',
      values: {
        name: nodeType
      }
    }),
    icon: 'metricsApp',
    ...(nodeType ? nodeDetailLinkProps : {}),
    'data-test-subj': 'metricsExplorerAction-ViewNodeMetrics'
  }] : [];
  const openInVisualize = uiCapabilities !== null && uiCapabilities !== void 0 && (_uiCapabilities$visua = uiCapabilities.visualize) !== null && _uiCapabilities$visua !== void 0 && _uiCapabilities$visua.show ? [{
    name: _i18n.i18n.translate('xpack.infra.metricsExplorer.openInTSVB', {
      defaultMessage: 'Open in Visualize'
    }),
    ...tsvbLinkProps,
    icon: 'visualizeApp',
    disabled: options.metrics.length === 0,
    'data-test-subj': 'metricsExplorerAction-OpenInTSVB'
  }] : [];
  const createAlert = uiCapabilities !== null && uiCapabilities !== void 0 && (_uiCapabilities$infra = uiCapabilities.infrastructure) !== null && _uiCapabilities$infra !== void 0 && _uiCapabilities$infra.save ? [{
    name: _i18n.i18n.translate('xpack.infra.metricsExplorer.alerts.createRuleButton', {
      defaultMessage: 'Create threshold rule'
    }),
    icon: 'bell',
    onClick() {
      setFlyoutVisible(true);
    }
  }] : [];
  const itemPanels = [...filterByItem, ...openInVisualize, ...viewNodeDetail, ...createAlert];

  // If there are no itemPanels then there is no reason to show the actions button.
  if (itemPanels.length === 0) return null;
  const panels = [{
    id: 0,
    title: 'Actions',
    items: itemPanels
  }];
  const handleClose = () => setPopoverState(false);
  const togglePopover = () => setPopoverState(currentIsOpen => !currentIsOpen);
  const actionAriaLabel = _i18n.i18n.translate('xpack.infra.metricsExplorer.actionsLabel.aria', {
    defaultMessage: 'Actions for {grouping}',
    values: {
      grouping: series.id
    }
  });
  const actionLabel = _i18n.i18n.translate('xpack.infra.metricsExplorer.actionsLabel.button', {
    defaultMessage: 'Actions'
  });
  const button = /*#__PURE__*/_react.default.createElement(_eui.EuiButtonEmpty, {
    "data-test-subj": "infraMetricsExplorerChartContextMenuButton",
    contentProps: {
      'aria-label': actionAriaLabel
    },
    onClick: togglePopover,
    size: "s",
    iconType: "arrowDown",
    iconSide: "right"
  }, actionLabel);
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_eui.EuiPopover, {
    closePopover: handleClose,
    id: `${series.id}-popover`,
    button: button,
    isOpen: isPopoverOpen,
    panelPaddingSize: "none"
  }, /*#__PURE__*/_react.default.createElement(_eui.EuiContextMenu, {
    initialPanelId: 0,
    panels: panels
  }), /*#__PURE__*/_react.default.createElement(_alert_flyout.AlertFlyout, {
    series: series,
    options: options,
    setVisible: setFlyoutVisible,
    visible: flyoutVisible
  })));
};
exports.MetricsExplorerChartContextMenu = MetricsExplorerChartContextMenu;