"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onSaveSearch = onSaveSearch;
var _react = _interopRequireWildcard(require("react"));
var _i18n = require("@kbn/i18n");
var _eui = require("@elastic/eui");
var _i18nReact = require("@kbn/i18n-react");
var _public = require("@kbn/saved-objects-plugin/public");
var _discoverUtils = require("@kbn/discover-utils");
var _get_allowed_sample_size = require("../../../../utils/get_allowed_sample_size");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

async function saveDataSource({
  savedSearch,
  saveOptions,
  services,
  state,
  navigateOrReloadSavedSearch
}) {
  const prevSavedSearchId = savedSearch.id;
  function onSuccess(id) {
    if (id) {
      services.toastNotifications.addSuccess({
        title: _i18n.i18n.translate('discover.notifications.savedSearchTitle', {
          defaultMessage: `Search '{savedSearchTitle}' was saved`,
          values: {
            savedSearchTitle: savedSearch.title
          }
        }),
        'data-test-subj': 'saveSearchSuccess'
      });
      if (navigateOrReloadSavedSearch) {
        if (id !== prevSavedSearchId) {
          services.locator.navigate({
            savedSearchId: id
          });
        } else {
          // Update defaults so that "reload saved query" functions correctly
          state.actions.undoSavedSearchChanges();
        }
      }
    }
  }
  function onError(error) {
    services.toastNotifications.addDanger({
      title: _i18n.i18n.translate('discover.notifications.notSavedSearchTitle', {
        defaultMessage: `Search '{savedSearchTitle}' was not saved.`,
        values: {
          savedSearchTitle: savedSearch.title
        }
      }),
      text: error.message
    });
  }
  try {
    const response = await state.savedSearchState.persist(savedSearch, saveOptions);
    if (response !== null && response !== void 0 && response.id) {
      onSuccess(response.id);
    }
    return response;
  } catch (error) {
    onError(error);
  }
}
async function onSaveSearch({
  savedSearch,
  services,
  state,
  initialCopyOnSave,
  onClose,
  onSaveCb
}) {
  var _dataView$isTimeBased, _savedSearch$title, _savedSearch$tags;
  const {
    uiSettings,
    savedObjectsTagging
  } = services;
  const dataView = state.internalState.getState().dataView;
  const onSave = async ({
    newTitle,
    newCopyOnSave,
    newTimeRestore,
    newDescription,
    newTags,
    isTitleDuplicateConfirmed,
    onTitleDuplicate
  }) => {
    const currentTitle = savedSearch.title;
    const currentTimeRestore = savedSearch.timeRestore;
    const currentRowsPerPage = savedSearch.rowsPerPage;
    const currentSampleSize = savedSearch.sampleSize;
    const currentDescription = savedSearch.description;
    const currentTags = savedSearch.tags;
    savedSearch.title = newTitle;
    savedSearch.description = newDescription;
    savedSearch.timeRestore = newTimeRestore;
    savedSearch.rowsPerPage = uiSettings.get(_discoverUtils.DOC_TABLE_LEGACY) ? currentRowsPerPage : state.appState.getState().rowsPerPage;

    // save the custom value or reset it if it's invalid
    const appStateSampleSize = state.appState.getState().sampleSize;
    const allowedSampleSize = (0, _get_allowed_sample_size.getAllowedSampleSize)(appStateSampleSize, uiSettings);
    savedSearch.sampleSize = appStateSampleSize && allowedSampleSize === appStateSampleSize ? appStateSampleSize : undefined;
    if (savedObjectsTagging) {
      savedSearch.tags = newTags;
    }
    const saveOptions = {
      onTitleDuplicate,
      copyOnSave: newCopyOnSave,
      isTitleDuplicateConfirmed
    };
    if (newCopyOnSave) {
      await state.actions.updateAdHocDataViewId();
    }
    const navigateOrReloadSavedSearch = !Boolean(onSaveCb);
    const response = await saveDataSource({
      saveOptions,
      services,
      savedSearch,
      state,
      navigateOrReloadSavedSearch
    });
    // If the save wasn't successful, put the original values back.
    if (!response) {
      savedSearch.title = currentTitle;
      savedSearch.timeRestore = currentTimeRestore;
      savedSearch.rowsPerPage = currentRowsPerPage;
      savedSearch.sampleSize = currentSampleSize;
      savedSearch.description = currentDescription;
      if (savedObjectsTagging) {
        savedSearch.tags = currentTags;
      }
    } else {
      state.appState.resetInitialState();
    }
    onSaveCb === null || onSaveCb === void 0 ? void 0 : onSaveCb();
    return response;
  };
  const saveModal = /*#__PURE__*/_react.default.createElement(SaveSearchObjectModal, {
    isTimeBased: (_dataView$isTimeBased = dataView === null || dataView === void 0 ? void 0 : dataView.isTimeBased()) !== null && _dataView$isTimeBased !== void 0 ? _dataView$isTimeBased : false,
    services: services,
    title: (_savedSearch$title = savedSearch.title) !== null && _savedSearch$title !== void 0 ? _savedSearch$title : '',
    showCopyOnSave: !!savedSearch.id,
    initialCopyOnSave: initialCopyOnSave,
    description: savedSearch.description,
    timeRestore: savedSearch.timeRestore,
    tags: (_savedSearch$tags = savedSearch.tags) !== null && _savedSearch$tags !== void 0 ? _savedSearch$tags : [],
    onSave: onSave,
    onClose: onClose !== null && onClose !== void 0 ? onClose : () => {}
  });
  (0, _public.showSaveModal)(saveModal);
}
const SaveSearchObjectModal = ({
  isTimeBased,
  services,
  title,
  description,
  tags,
  showCopyOnSave,
  initialCopyOnSave,
  timeRestore: savedTimeRestore,
  onSave,
  onClose
}) => {
  const {
    savedObjectsTagging
  } = services;
  const [timeRestore, setTimeRestore] = (0, _react.useState)(isTimeBased && savedTimeRestore || false);
  const [currentTags, setCurrentTags] = (0, _react.useState)(tags);
  const onModalSave = params => {
    onSave({
      ...params,
      newTimeRestore: timeRestore,
      newTags: currentTags
    });
  };
  const tagSelector = savedObjectsTagging ? /*#__PURE__*/_react.default.createElement(savedObjectsTagging.ui.components.SavedObjectSaveModalTagSelector, {
    initialSelection: currentTags,
    onTagsSelected: newTags => {
      setCurrentTags(newTags);
    }
  }) : undefined;
  const timeSwitch = isTimeBased ? /*#__PURE__*/_react.default.createElement(_eui.EuiFormRow, {
    helpText: /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedMessage, {
      id: "discover.topNav.saveModal.storeTimeWithSearchToggleDescription",
      defaultMessage: "Update the time filter and refresh interval to the current selection when using this search."
    })
  }, /*#__PURE__*/_react.default.createElement(_eui.EuiSwitch, {
    "data-test-subj": "storeTimeWithSearch",
    checked: timeRestore,
    onChange: event => setTimeRestore(event.target.checked),
    label: /*#__PURE__*/_react.default.createElement(_i18nReact.FormattedMessage, {
      id: "discover.topNav.saveModal.storeTimeWithSearchToggleLabel",
      defaultMessage: "Store time with saved search"
    })
  })) : null;
  const options = tagSelector ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, tagSelector, timeSwitch) : timeSwitch;
  return /*#__PURE__*/_react.default.createElement(_public.SavedObjectSaveModal, {
    title: title,
    showCopyOnSave: showCopyOnSave,
    initialCopyOnSave: initialCopyOnSave,
    description: description,
    objectType: _i18n.i18n.translate('discover.localMenu.saveSaveSearchObjectType', {
      defaultMessage: 'search'
    }),
    showDescription: true,
    options: options,
    onSave: onModalSave,
    onClose: onClose
  });
};