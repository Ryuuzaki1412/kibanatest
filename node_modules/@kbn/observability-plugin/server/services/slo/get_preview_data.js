"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GetPreviewData = void 0;
var _calculateAuto = require("@kbn/calculate-auto");
var _esQuery = require("@kbn/es-query");
var _sloSchema = require("@kbn/slo-schema");
var _std = require("@kbn/std");
var _moment = _interopRequireDefault(require("moment"));
var _queries = require("../../utils/queries");
var _services = require("../../domain/services");
var _errors = require("../../errors");
var _aggregations = require("./aggregations");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

class GetPreviewData {
  constructor(esClient) {
    this.esClient = esClient;
  }
  async getAPMTransactionDurationPreviewData(indicator, options) {
    var _result$aggregations$, _result$aggregations;
    const filter = [];
    if (indicator.params.service !== _sloSchema.ALL_VALUE) filter.push({
      match: {
        'service.name': indicator.params.service
      }
    });
    if (indicator.params.environment !== _sloSchema.ALL_VALUE) filter.push({
      match: {
        'service.environment': indicator.params.environment
      }
    });
    if (indicator.params.transactionName !== _sloSchema.ALL_VALUE) filter.push({
      match: {
        'transaction.name': indicator.params.transactionName
      }
    });
    if (indicator.params.transactionType !== _sloSchema.ALL_VALUE) filter.push({
      match: {
        'transaction.type': indicator.params.transactionType
      }
    });
    if (!!indicator.params.filter) filter.push(getElasticsearchQueryOrThrow(indicator.params.filter));
    const truncatedThreshold = Math.trunc(indicator.params.threshold * 1000);
    const result = await (0, _queries.typedSearch)(this.esClient, {
      index: indicator.params.index,
      size: 0,
      query: {
        bool: {
          filter: [{
            range: {
              '@timestamp': {
                gte: options.range.start,
                lte: options.range.end
              }
            }
          }, {
            terms: {
              'processor.event': ['metric']
            }
          }, {
            term: {
              'metricset.name': 'transaction'
            }
          }, {
            exists: {
              field: 'transaction.duration.histogram'
            }
          }, ...filter]
        }
      },
      aggs: {
        perMinute: {
          date_histogram: {
            field: '@timestamp',
            fixed_interval: options.interval
          },
          aggs: {
            _good: {
              range: {
                field: 'transaction.duration.histogram',
                keyed: true,
                ranges: [{
                  to: truncatedThreshold,
                  key: 'target'
                }]
              }
            },
            good: {
              bucket_script: {
                buckets_path: {
                  _good: `_good['target']>_count`
                },
                script: 'params._good'
              }
            },
            total: {
              value_count: {
                field: 'transaction.duration.histogram'
              }
            }
          }
        }
      }
    });
    return (_result$aggregations$ = (_result$aggregations = result.aggregations) === null || _result$aggregations === void 0 ? void 0 : _result$aggregations.perMinute.buckets.map(bucket => {
      var _ref, _bucket$good, _bucket$total$value, _bucket$total;
      const good = (_ref = (_bucket$good = bucket.good) === null || _bucket$good === void 0 ? void 0 : _bucket$good.value) !== null && _ref !== void 0 ? _ref : 0;
      const total = (_bucket$total$value = (_bucket$total = bucket.total) === null || _bucket$total === void 0 ? void 0 : _bucket$total.value) !== null && _bucket$total$value !== void 0 ? _bucket$total$value : 0;
      return {
        date: bucket.key_as_string,
        sliValue: (0, _services.computeSLI)(good, total),
        events: {
          good,
          total,
          bad: total - good
        }
      };
    })) !== null && _result$aggregations$ !== void 0 ? _result$aggregations$ : [];
  }
  async getAPMTransactionErrorPreviewData(indicator, options) {
    var _result$aggregations2;
    const filter = [];
    if (indicator.params.service !== _sloSchema.ALL_VALUE) filter.push({
      match: {
        'service.name': indicator.params.service
      }
    });
    if (indicator.params.environment !== _sloSchema.ALL_VALUE) filter.push({
      match: {
        'service.environment': indicator.params.environment
      }
    });
    if (indicator.params.transactionName !== _sloSchema.ALL_VALUE) filter.push({
      match: {
        'transaction.name': indicator.params.transactionName
      }
    });
    if (indicator.params.transactionType !== _sloSchema.ALL_VALUE) filter.push({
      match: {
        'transaction.type': indicator.params.transactionType
      }
    });
    if (!!indicator.params.filter) filter.push(getElasticsearchQueryOrThrow(indicator.params.filter));
    const result = await this.esClient.search({
      index: indicator.params.index,
      size: 0,
      query: {
        bool: {
          filter: [{
            range: {
              '@timestamp': {
                gte: options.range.start,
                lte: options.range.end
              }
            }
          }, {
            term: {
              'metricset.name': 'transaction'
            }
          }, {
            terms: {
              'event.outcome': ['success', 'failure']
            }
          }, ...filter]
        }
      },
      aggs: {
        perMinute: {
          date_histogram: {
            field: '@timestamp',
            fixed_interval: options.interval
          },
          aggs: {
            good: {
              filter: {
                bool: {
                  should: {
                    match: {
                      'event.outcome': 'success'
                    }
                  }
                }
              }
            },
            total: {
              filter: {
                match_all: {}
              }
            }
          }
        }
      }
    });

    // @ts-ignore buckets is not improperly typed
    return (_result$aggregations2 = result.aggregations) === null || _result$aggregations2 === void 0 ? void 0 : _result$aggregations2.perMinute.buckets.map(bucket => {
      var _bucket$good$doc_coun, _bucket$good2, _bucket$total$doc_cou, _bucket$total2, _bucket$good$doc_coun2, _bucket$good3, _bucket$total$doc_cou2, _bucket$total3;
      return {
        date: bucket.key_as_string,
        sliValue: !!bucket.good && !!bucket.total ? (0, _services.computeSLI)(bucket.good.doc_count, bucket.total.doc_count) : null,
        events: {
          good: (_bucket$good$doc_coun = (_bucket$good2 = bucket.good) === null || _bucket$good2 === void 0 ? void 0 : _bucket$good2.doc_count) !== null && _bucket$good$doc_coun !== void 0 ? _bucket$good$doc_coun : 0,
          bad: ((_bucket$total$doc_cou = (_bucket$total2 = bucket.total) === null || _bucket$total2 === void 0 ? void 0 : _bucket$total2.doc_count) !== null && _bucket$total$doc_cou !== void 0 ? _bucket$total$doc_cou : 0) - ((_bucket$good$doc_coun2 = (_bucket$good3 = bucket.good) === null || _bucket$good3 === void 0 ? void 0 : _bucket$good3.doc_count) !== null && _bucket$good$doc_coun2 !== void 0 ? _bucket$good$doc_coun2 : 0),
          total: (_bucket$total$doc_cou2 = (_bucket$total3 = bucket.total) === null || _bucket$total3 === void 0 ? void 0 : _bucket$total3.doc_count) !== null && _bucket$total$doc_cou2 !== void 0 ? _bucket$total$doc_cou2 : 0
        }
      };
    });
  }
  async getHistogramPreviewData(indicator, options) {
    var _result$aggregations3;
    const getHistogramIndicatorAggregations = new _aggregations.GetHistogramIndicatorAggregation(indicator);
    const filterQuery = getElasticsearchQueryOrThrow(indicator.params.filter);
    const timestampField = indicator.params.timestampField;
    const result = await this.esClient.search({
      index: indicator.params.index,
      size: 0,
      query: {
        bool: {
          filter: [{
            range: {
              [timestampField]: {
                gte: options.range.start,
                lte: options.range.end
              }
            }
          }, filterQuery]
        }
      },
      aggs: {
        perMinute: {
          date_histogram: {
            field: timestampField,
            fixed_interval: options.interval
          },
          aggs: {
            ...getHistogramIndicatorAggregations.execute({
              type: 'good',
              aggregationKey: 'good'
            }),
            ...getHistogramIndicatorAggregations.execute({
              type: 'total',
              aggregationKey: 'total'
            })
          }
        }
      }
    });

    // @ts-ignore buckets is not improperly typed
    return (_result$aggregations3 = result.aggregations) === null || _result$aggregations3 === void 0 ? void 0 : _result$aggregations3.perMinute.buckets.map(bucket => {
      var _bucket$good$value, _bucket$good4, _bucket$total$value2, _bucket$total4, _bucket$good$value2, _bucket$good5, _bucket$total$value3, _bucket$total5;
      return {
        date: bucket.key_as_string,
        sliValue: !!bucket.good && !!bucket.total ? (0, _services.computeSLI)(bucket.good.value, bucket.total.value) : null,
        events: {
          good: (_bucket$good$value = (_bucket$good4 = bucket.good) === null || _bucket$good4 === void 0 ? void 0 : _bucket$good4.value) !== null && _bucket$good$value !== void 0 ? _bucket$good$value : 0,
          bad: ((_bucket$total$value2 = (_bucket$total4 = bucket.total) === null || _bucket$total4 === void 0 ? void 0 : _bucket$total4.value) !== null && _bucket$total$value2 !== void 0 ? _bucket$total$value2 : 0) - ((_bucket$good$value2 = (_bucket$good5 = bucket.good) === null || _bucket$good5 === void 0 ? void 0 : _bucket$good5.value) !== null && _bucket$good$value2 !== void 0 ? _bucket$good$value2 : 0),
          total: (_bucket$total$value3 = (_bucket$total5 = bucket.total) === null || _bucket$total5 === void 0 ? void 0 : _bucket$total5.value) !== null && _bucket$total$value3 !== void 0 ? _bucket$total$value3 : 0
        }
      };
    });
  }
  async getCustomMetricPreviewData(indicator, options) {
    var _result$aggregations4;
    const timestampField = indicator.params.timestampField;
    const filterQuery = getElasticsearchQueryOrThrow(indicator.params.filter);
    const getCustomMetricIndicatorAggregation = new _aggregations.GetCustomMetricIndicatorAggregation(indicator);
    const result = await this.esClient.search({
      index: indicator.params.index,
      size: 0,
      query: {
        bool: {
          filter: [{
            range: {
              [timestampField]: {
                gte: options.range.start,
                lte: options.range.end
              }
            }
          }, filterQuery]
        }
      },
      aggs: {
        perMinute: {
          date_histogram: {
            field: timestampField,
            fixed_interval: options.interval
          },
          aggs: {
            ...getCustomMetricIndicatorAggregation.execute({
              type: 'good',
              aggregationKey: 'good'
            }),
            ...getCustomMetricIndicatorAggregation.execute({
              type: 'total',
              aggregationKey: 'total'
            })
          }
        }
      }
    });

    // @ts-ignore buckets is not improperly typed
    return (_result$aggregations4 = result.aggregations) === null || _result$aggregations4 === void 0 ? void 0 : _result$aggregations4.perMinute.buckets.map(bucket => {
      var _bucket$good$value3, _bucket$good6, _bucket$total$value4, _bucket$total6, _bucket$good$value4, _bucket$good7, _bucket$total$value5, _bucket$total7;
      return {
        date: bucket.key_as_string,
        sliValue: !!bucket.good && !!bucket.total ? (0, _services.computeSLI)(bucket.good.value, bucket.total.value) : null,
        events: {
          good: (_bucket$good$value3 = (_bucket$good6 = bucket.good) === null || _bucket$good6 === void 0 ? void 0 : _bucket$good6.value) !== null && _bucket$good$value3 !== void 0 ? _bucket$good$value3 : 0,
          bad: ((_bucket$total$value4 = (_bucket$total6 = bucket.total) === null || _bucket$total6 === void 0 ? void 0 : _bucket$total6.value) !== null && _bucket$total$value4 !== void 0 ? _bucket$total$value4 : 0) - ((_bucket$good$value4 = (_bucket$good7 = bucket.good) === null || _bucket$good7 === void 0 ? void 0 : _bucket$good7.value) !== null && _bucket$good$value4 !== void 0 ? _bucket$good$value4 : 0),
          total: (_bucket$total$value5 = (_bucket$total7 = bucket.total) === null || _bucket$total7 === void 0 ? void 0 : _bucket$total7.value) !== null && _bucket$total$value5 !== void 0 ? _bucket$total$value5 : 0
        }
      };
    });
  }
  async getTimesliceMetricPreviewData(indicator, options) {
    var _result$aggregations5;
    const timestampField = indicator.params.timestampField;
    const filterQuery = getElasticsearchQueryOrThrow(indicator.params.filter);
    const getCustomMetricIndicatorAggregation = new _aggregations.GetTimesliceMetricIndicatorAggregation(indicator);
    const result = await this.esClient.search({
      index: indicator.params.index,
      size: 0,
      query: {
        bool: {
          filter: [{
            range: {
              [timestampField]: {
                gte: options.range.start,
                lte: options.range.end
              }
            }
          }, filterQuery]
        }
      },
      aggs: {
        perMinute: {
          date_histogram: {
            field: timestampField,
            fixed_interval: options.interval
          },
          aggs: {
            ...getCustomMetricIndicatorAggregation.execute('metric')
          }
        }
      }
    });

    // @ts-ignore buckets is not improperly typed
    return (_result$aggregations5 = result.aggregations) === null || _result$aggregations5 === void 0 ? void 0 : _result$aggregations5.perMinute.buckets.map(bucket => ({
      date: bucket.key_as_string,
      sliValue: !!bucket.metric ? bucket.metric.value : null
    }));
  }
  async getCustomKQLPreviewData(indicator, options) {
    var _result$aggregations6;
    const filterQuery = getElasticsearchQueryOrThrow(indicator.params.filter);
    const goodQuery = getElasticsearchQueryOrThrow(indicator.params.good);
    const totalQuery = getElasticsearchQueryOrThrow(indicator.params.total);
    const timestampField = indicator.params.timestampField;
    const result = await this.esClient.search({
      index: indicator.params.index,
      size: 0,
      query: {
        bool: {
          filter: [{
            range: {
              [timestampField]: {
                gte: options.range.start,
                lte: options.range.end
              }
            }
          }, filterQuery]
        }
      },
      aggs: {
        perMinute: {
          date_histogram: {
            field: timestampField,
            fixed_interval: options.interval
          },
          aggs: {
            good: {
              filter: goodQuery
            },
            total: {
              filter: totalQuery
            }
          }
        }
      }
    });

    // @ts-ignore buckets is not improperly typed
    return (_result$aggregations6 = result.aggregations) === null || _result$aggregations6 === void 0 ? void 0 : _result$aggregations6.perMinute.buckets.map(bucket => {
      var _bucket$good$doc_coun3, _bucket$good8, _bucket$total$doc_cou3, _bucket$total8, _bucket$good$doc_coun4, _bucket$good9, _bucket$total$doc_cou4, _bucket$total9;
      return {
        date: bucket.key_as_string,
        sliValue: !!bucket.good && !!bucket.total ? (0, _services.computeSLI)(bucket.good.doc_count, bucket.total.doc_count) : null,
        events: {
          good: (_bucket$good$doc_coun3 = (_bucket$good8 = bucket.good) === null || _bucket$good8 === void 0 ? void 0 : _bucket$good8.doc_count) !== null && _bucket$good$doc_coun3 !== void 0 ? _bucket$good$doc_coun3 : 0,
          bad: ((_bucket$total$doc_cou3 = (_bucket$total8 = bucket.total) === null || _bucket$total8 === void 0 ? void 0 : _bucket$total8.doc_count) !== null && _bucket$total$doc_cou3 !== void 0 ? _bucket$total$doc_cou3 : 0) - ((_bucket$good$doc_coun4 = (_bucket$good9 = bucket.good) === null || _bucket$good9 === void 0 ? void 0 : _bucket$good9.doc_count) !== null && _bucket$good$doc_coun4 !== void 0 ? _bucket$good$doc_coun4 : 0),
          total: (_bucket$total$doc_cou4 = (_bucket$total9 = bucket.total) === null || _bucket$total9 === void 0 ? void 0 : _bucket$total9.doc_count) !== null && _bucket$total$doc_cou4 !== void 0 ? _bucket$total$doc_cou4 : 0
        }
      };
    });
  }
  async execute(params) {
    try {
      var _calculateAuto$near$a, _calculateAuto$near;
      const bucketSize = Math.max((_calculateAuto$near$a = (_calculateAuto$near = _calculateAuto.calculateAuto.near(100, _moment.default.duration(params.range.end - params.range.start, 'ms'))) === null || _calculateAuto$near === void 0 ? void 0 : _calculateAuto$near.asMinutes()) !== null && _calculateAuto$near$a !== void 0 ? _calculateAuto$near$a : 0, 1);
      const options = {
        range: params.range,
        interval: `${bucketSize}m`
      };
      const type = params.indicator.type;
      switch (type) {
        case 'sli.apm.transactionDuration':
          return this.getAPMTransactionDurationPreviewData(params.indicator, options);
        case 'sli.apm.transactionErrorRate':
          return this.getAPMTransactionErrorPreviewData(params.indicator, options);
        case 'sli.kql.custom':
          return this.getCustomKQLPreviewData(params.indicator, options);
        case 'sli.histogram.custom':
          return this.getHistogramPreviewData(params.indicator, options);
        case 'sli.metric.custom':
          return this.getCustomMetricPreviewData(params.indicator, options);
        case 'sli.metric.timeslice':
          return this.getTimesliceMetricPreviewData(params.indicator, options);
        default:
          (0, _std.assertNever)(type);
      }
    } catch (err) {
      return [];
    }
  }
}
exports.GetPreviewData = GetPreviewData;
function getElasticsearchQueryOrThrow(kuery = '') {
  try {
    return (0, _esQuery.toElasticsearchQuery)((0, _esQuery.fromKueryExpression)(kuery));
  } catch (err) {
    throw new _errors.InvalidQueryError(`Invalid kuery: ${kuery}`);
  }
}